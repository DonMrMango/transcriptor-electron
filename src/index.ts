import { app, BrowserWindow, ipcMain, clipboard, dialog, globalShortcut } from 'electron';
import { spawn } from 'child_process';
import * as path from 'path';
import * as fs from 'fs';
import Database from 'better-sqlite3';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Global reference to the main window
let mainWindow: BrowserWindow | null = null;

const createWindow = (): void => {
  // Create a compact widget-style window
  mainWindow = new BrowserWindow({
    width: 320,
    height: 550,
    transparent: false,
    frame: false,
    alwaysOnTop: true,
    resizable: false,
    skipTaskbar: false,
    backgroundColor: '#1e1e2e',
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools in development mode
  if (process.env.NODE_ENV !== 'production') {
    mainWindow.webContents.openDevTools({ mode: 'detach' });
  }

  // Handle window closed
  mainWindow.on('closed', () => {
    mainWindow = null;
  });
};

// API Key storage
const API_KEY_FILE = path.join(app.getPath('userData'), 'groq_api_key.txt');

// Database setup
const DB_PATH = path.join(app.getPath('userData'), 'transcriptions.db');
let db: Database.Database | null = null;

function initDatabase() {
  try {
    console.log('[DB] Initializing database at:', DB_PATH);
    db = new Database(DB_PATH);

    // Create transcriptions table
    db.exec(`
      CREATE TABLE IF NOT EXISTS transcriptions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        text TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        duration REAL,
        language TEXT,
        model TEXT
      )
    `);

    console.log('[DB] Database initialized successfully');
  } catch (error) {
    console.error('[DB] Error initializing database:', error);
  }
}

// Setup IPC handlers once (globally)
function setupIPC() {
  // Control de ventana
  ipcMain.on('window-close', () => {
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.close();
    }
  });

  ipcMain.on('window-minimize', () => {
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.minimize();
    }
  });

  ipcMain.on('window-maximize', () => {
    if (mainWindow && !mainWindow.isDestroyed()) {
      if (mainWindow.isMaximized()) {
        mainWindow.unmaximize();
      } else {
        mainWindow.maximize();
      }
    }
  });

  ipcMain.on('window-resize', (event, { width, height }) => {
    if (mainWindow && !mainWindow.isDestroyed()) {
      console.log('[WINDOW] Resizing to:', width, 'x', height);
      mainWindow.setSize(width, height, true);
      mainWindow.center();
    }
  });

  ipcMain.on('window-set-resizable', (event, resizable: boolean) => {
    if (mainWindow && !mainWindow.isDestroyed()) {
      console.log('[WINDOW] Set resizable:', resizable);
      mainWindow.setResizable(resizable);
    }
  });

  ipcMain.handle('window-is-maximized', () => {
    if (mainWindow && !mainWindow.isDestroyed()) {
      return mainWindow.isMaximized();
    }
    return false;
  });

  // Toggle recording (para atajo de teclado)
  ipcMain.on('toggle-recording-shortcut', () => {
    console.log('[SHORTCUT] Toggle recording triggered');
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.webContents.send('toggle-recording');
    }
  });

  // API Key management
  ipcMain.handle('get-api-key', async () => {
    try {
      console.log('[API_KEY] Checking for API key at:', API_KEY_FILE);
      if (fs.existsSync(API_KEY_FILE)) {
        const apiKey = fs.readFileSync(API_KEY_FILE, 'utf-8').trim();
        console.log('[API_KEY] Found API key:', apiKey.substring(0, 10) + '...');
        return apiKey;
      }
      console.log('[API_KEY] No API key file found');
      return null;
    } catch (error) {
      console.error('[API_KEY] Error reading API key:', error);
      return null;
    }
  });

  ipcMain.handle('save-api-key', async (event, apiKey: string) => {
    try {
      console.log('[API_KEY] Saving API key to:', API_KEY_FILE);
      fs.writeFileSync(API_KEY_FILE, apiKey.trim());
      console.log('[API_KEY] API key saved successfully');
      return { success: true };
    } catch (error: any) {
      console.error('[API_KEY] Error saving API key:', error);
      return { success: false, error: error.message };
    }
  });

  // File dialog para seleccionar archivo
  ipcMain.handle('open-file-dialog', async () => {
    try {
      const result = await dialog.showOpenDialog(mainWindow!, {
        properties: ['openFile'],
        filters: [
          { name: 'Audio/Video', extensions: ['mp3', 'wav', 'webm', 'mp4', 'm4a', 'ogg', 'flac', 'aac', 'wma', 'avi', 'mov', 'mkv'] },
          { name: 'All Files', extensions: ['*'] }
        ]
      });

      if (result.canceled) {
        return { success: false, canceled: true };
      }

      return { success: true, filePath: result.filePaths[0] };
    } catch (error: any) {
      console.error('[FILE_DIALOG] Error:', error);
      return { success: false, error: error.message };
    }
  });

  // Transcribir archivo desde path
  ipcMain.handle('transcribe-file', async (event, filePath: string, apiKey: string) => {
    try {
      console.log('[TRANSCRIBE_FILE] Starting transcription for file:', filePath);
      console.log('[TRANSCRIBE_FILE] API key:', apiKey.substring(0, 10) + '...');

      if (!fs.existsSync(filePath)) {
        return { success: false, error: 'File not found' };
      }

      // Ruta al CLI de Python
      const pythonCli = path.join(__dirname, '../../python-engine/cli.py');
      console.log('[TRANSCRIBE_FILE] Python CLI path:', pythonCli);

      // Llamar al CLI de Python directamente con el archivo
      return new Promise((resolve) => {
        const python = spawn('python3', [
          pythonCli,
          'transcribe',
          filePath,
          apiKey,
          'es',
          'whisper-large-v3-turbo'
        ], {
          stdio: ['ignore', 'pipe', 'pipe']
        });

        let outputData = '';
        let errorData = '';

        python.stdout.on('data', (data) => {
          const dataStr = data.toString();
          outputData += dataStr;
        });

        python.stderr.on('data', (data) => {
          const dataStr = data.toString();
          errorData += dataStr;
        });

        python.on('close', (code) => {
          console.log('[TRANSCRIBE_FILE] Python process closed with code:', code);

          if (code !== 0) {
            console.log('[TRANSCRIBE_FILE] Python failed with code:', code);
            resolve({ success: false, error: errorData || 'Error en transcripción' });
            return;
          }

          try {
            const result = JSON.parse(outputData);
            console.log('[TRANSCRIBE_FILE] Parsed result:', result);

            // Copiar al clipboard
            if (result.success && result.text) {
              clipboard.writeText(result.text);
              console.log('[TRANSCRIBE_FILE] Text copied to clipboard');
            }

            resolve(result);
          } catch (err) {
            console.error('[TRANSCRIBE_FILE] Error parsing JSON:', err);
            resolve({ success: false, error: 'Error parsing JSON: ' + err });
          }
        });

        python.on('error', (err) => {
          console.error('[TRANSCRIBE_FILE] Python process error:', err);
          resolve({ success: false, error: 'Failed to start Python: ' + err.message });
        });
      });
    } catch (error: any) {
      console.error('[TRANSCRIBE_FILE] Caught exception:', error);
      return { success: false, error: error.message };
    }
  });

  // Transcribir desde URL de YouTube
  ipcMain.handle('transcribe-youtube', async (event, youtubeUrl: string, apiKey: string) => {
    try {
      console.log('[TRANSCRIBE_YOUTUBE] Starting transcription for YouTube URL:', youtubeUrl);
      console.log('[TRANSCRIBE_YOUTUBE] API key:', apiKey.substring(0, 10) + '...');

      // Ruta al CLI de Python
      const pythonCli = path.join(__dirname, '../../python-engine/cli.py');
      console.log('[TRANSCRIBE_YOUTUBE] Python CLI path:', pythonCli);

      // Llamar al CLI de Python con el comando youtube
      return new Promise((resolve) => {
        const python = spawn('python3', [
          pythonCli,
          'youtube',
          youtubeUrl,
          apiKey,
          'es',
          'whisper-large-v3-turbo'
        ], {
          stdio: ['ignore', 'pipe', 'pipe']
        });

        let outputData = '';
        let errorData = '';

        python.stdout.on('data', (data) => {
          const dataStr = data.toString();
          outputData += dataStr;
        });

        python.stderr.on('data', (data) => {
          const dataStr = data.toString();
          errorData += dataStr;
        });

        python.on('close', (code) => {
          console.log('[TRANSCRIBE_YOUTUBE] Python process closed with code:', code);

          if (code !== 0) {
            console.log('[TRANSCRIBE_YOUTUBE] Python failed with code:', code);
            resolve({ success: false, error: errorData || 'Error descargando o transcribiendo YouTube' });
            return;
          }

          try {
            const result = JSON.parse(outputData);
            console.log('[TRANSCRIBE_YOUTUBE] Parsed result:', result);

            // Copiar al clipboard
            if (result.success && result.text) {
              clipboard.writeText(result.text);
              console.log('[TRANSCRIBE_YOUTUBE] Text copied to clipboard');
            }

            resolve(result);
          } catch (err) {
            console.error('[TRANSCRIBE_YOUTUBE] Error parsing JSON:', err);
            resolve({ success: false, error: 'Error parsing JSON: ' + err });
          }
        });

        python.on('error', (err) => {
          console.error('[TRANSCRIBE_YOUTUBE] Python process error:', err);
          resolve({ success: false, error: 'Failed to start Python: ' + err.message });
        });
      });
    } catch (error: any) {
      console.error('[TRANSCRIBE_YOUTUBE] Caught exception:', error);
      return { success: false, error: error.message };
    }
  });

  // Transcripción
  ipcMain.handle('transcribe-audio', async (event, audioBlob: Buffer, apiKey: string) => {
    try {
      console.log('[TRANSCRIBE] Starting transcription');
      console.log('[TRANSCRIBE] Audio blob size:', audioBlob.length, 'bytes');
      console.log('[TRANSCRIBE] API key:', apiKey.substring(0, 10) + '...');

      // Guardar el blob de audio temporalmente
      const tempDir = app.getPath('temp');
      const audioPath = path.join(tempDir, `recording-${Date.now()}.webm`);
      console.log('[TRANSCRIBE] Saving audio to:', audioPath);

      fs.writeFileSync(audioPath, audioBlob);
      console.log('[TRANSCRIBE] Audio saved successfully');

      // Ruta al CLI de Python
      const pythonCli = path.join(__dirname, '../../python-engine/cli.py');
      console.log('[TRANSCRIBE] Python CLI path:', pythonCli);
      console.log('[TRANSCRIBE] Python CLI exists?', fs.existsSync(pythonCli));

      // Llamar al CLI de Python
      return new Promise((resolve, reject) => {
        console.log('[TRANSCRIBE] Spawning Python process...');
        const python = spawn('python3', [
          pythonCli,
          'transcribe',
          audioPath,
          apiKey,
          'es',
          'whisper-large-v3-turbo'
        ], {
          stdio: ['ignore', 'pipe', 'pipe'] // stdin cerrado, stdout/stderr pipes
        });

        console.log('[TRANSCRIBE] Python process spawned');

        let outputData = '';
        let errorData = '';

        python.stdout.on('data', (data) => {
          const dataStr = data.toString();
          outputData += dataStr;
        });

        python.stderr.on('data', (data) => {
          const dataStr = data.toString();
          errorData += dataStr;
        });

        python.on('close', (code) => {
          console.log('[TRANSCRIBE] Python process closed with code:', code);
          // Limpiar archivo temporal
          try {
            fs.unlinkSync(audioPath);
          } catch (err) {
            console.error('Error deleting temp file:', err);
          }

          if (code !== 0) {
            console.log('[TRANSCRIBE] Python failed with code:', code);
            console.log('[TRANSCRIBE] Error output:', errorData);
            resolve({ success: false, error: errorData || 'Error en transcripción' });
            return;
          }

          try {
            console.log('[TRANSCRIBE] Parsing JSON output:', outputData);
            const result = JSON.parse(outputData);
            console.log('[TRANSCRIBE] Parsed result:', result);

            // Copiar al clipboard automáticamente
            if (result.success && result.text) {
              console.log('[TRANSCRIBE] Copying to clipboard:', result.text.substring(0, 50) + '...');
              clipboard.writeText(result.text);
              console.log('[TRANSCRIBE] Text copied to clipboard');
            }

            resolve(result);
          } catch (err) {
            console.error('[TRANSCRIBE] Error parsing JSON:', err);
            console.log('[TRANSCRIBE] Raw output was:', outputData);
            resolve({ success: false, error: 'Error parsing JSON: ' + err });
          }
        });

        python.on('error', (err) => {
          console.error('[TRANSCRIBE] Python process error:', err);
          resolve({ success: false, error: 'Failed to start Python: ' + err.message });
        });
      });
    } catch (error: any) {
      console.error('[TRANSCRIBE] Caught exception:', error);
      return { success: false, error: error.message };
    }
  });

  // Historial
  ipcMain.handle('save-transcription', async (event, data: any) => {
    try {
      if (!db) {
        console.error('[DB] Database not initialized');
        return { success: false, error: 'Database not initialized' };
      }

      console.log('[DB] Saving transcription:', data);

      const stmt = db.prepare(`
        INSERT INTO transcriptions (text, timestamp, duration, language, model)
        VALUES (?, ?, ?, ?, ?)
      `);

      const info = stmt.run(
        data.text,
        data.timestamp || Date.now(),
        data.duration || null,
        data.language || 'es',
        data.model || 'whisper-large-v3-turbo'
      );

      console.log('[DB] Transcription saved with id:', info.lastInsertRowid);
      return { success: true, id: info.lastInsertRowid };
    } catch (error: any) {
      console.error('[DB] Error saving transcription:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('get-history', async () => {
    try {
      if (!db) {
        console.error('[DB] Database not initialized');
        return [];
      }

      console.log('[DB] Retrieving transcription history');

      const stmt = db.prepare(`
        SELECT * FROM transcriptions
        ORDER BY timestamp DESC
        LIMIT 100
      `);

      const rows = stmt.all();
      console.log('[DB] Retrieved', rows.length, 'transcriptions');

      return rows;
    } catch (error: any) {
      console.error('[DB] Error retrieving history:', error);
      return [];
    }
  });

  ipcMain.handle('search-transcriptions', async (event, query: string) => {
    try {
      if (!db) {
        console.error('[DB] Database not initialized');
        return [];
      }

      if (!query || query.trim() === '') {
        // Si no hay query, retornar todo el historial
        const stmt = db.prepare(`
          SELECT * FROM transcriptions
          ORDER BY timestamp DESC
          LIMIT 100
        `);
        return stmt.all();
      }

      console.log('[DB] Searching transcriptions for:', query);

      // Búsqueda case-insensitive usando LIKE
      const stmt = db.prepare(`
        SELECT * FROM transcriptions
        WHERE text LIKE ?
        ORDER BY timestamp DESC
        LIMIT 100
      `);

      const searchPattern = `%${query}%`;
      const rows = stmt.all(searchPattern);
      console.log('[DB] Found', rows.length, 'matching transcriptions');

      return rows;
    } catch (error: any) {
      console.error('[DB] Error searching transcriptions:', error);
      return [];
    }
  });

  // PDF Tools - Select multiple PDF files
  ipcMain.handle('select-pdf-files', async () => {
    try {
      const result = await dialog.showOpenDialog(mainWindow!, {
        properties: ['openFile', 'multiSelections'],
        filters: [
          { name: 'PDF Files', extensions: ['pdf'] },
          { name: 'All Files', extensions: ['*'] }
        ]
      });

      if (result.canceled) {
        return { success: false, canceled: true };
      }

      return { success: true, filePaths: result.filePaths };
    } catch (error: any) {
      console.error('[PDF] Error selecting files:', error);
      return { success: false, error: error.message };
    }
  });

  // PDF Tools - Combine PDFs
  ipcMain.handle('combine-pdfs', async (event, filePaths: string[]) => {
    try {
      console.log('[PDF] Combining PDFs:', filePaths);

      const { PDFDocument } = await import('pdf-lib');
      const mergedPdf = await PDFDocument.create();

      // Read and merge all PDFs
      for (const filePath of filePaths) {
        const pdfBytes = fs.readFileSync(filePath);
        const pdf = await PDFDocument.load(pdfBytes);
        const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
        copiedPages.forEach((page) => mergedPdf.addPage(page));
      }

      // Save merged PDF
      const mergedPdfBytes = await mergedPdf.save();

      // Ask user where to save
      const saveResult = await dialog.showSaveDialog(mainWindow!, {
        defaultPath: 'combined.pdf',
        filters: [{ name: 'PDF Files', extensions: ['pdf'] }]
      });

      if (saveResult.canceled) {
        return { success: false, canceled: true };
      }

      // Write to file
      fs.writeFileSync(saveResult.filePath!, Buffer.from(mergedPdfBytes));

      console.log('[PDF] Combined PDF saved to:', saveResult.filePath);
      return { success: true, filePath: saveResult.filePath };
    } catch (error: any) {
      console.error('[PDF] Error combining PDFs:', error);
      return { success: false, error: error.message };
    }
  });

  // PDF Tools - Select single PDF file
  ipcMain.handle('select-single-pdf', async () => {
    try {
      const result = await dialog.showOpenDialog(mainWindow!, {
        properties: ['openFile'],
        filters: [
          { name: 'PDF Files', extensions: ['pdf'] },
          { name: 'All Files', extensions: ['*'] }
        ]
      });

      if (result.canceled) {
        return { success: false, canceled: true };
      }

      return { success: true, filePath: result.filePaths[0] };
    } catch (error: any) {
      console.error('[PDF] Error selecting file:', error);
      return { success: false, error: error.message };
    }
  });

  // PDF Tools - Get PDF page count
  ipcMain.handle('get-pdf-page-count', async (event, filePath: string) => {
    try {
      const { PDFDocument } = await import('pdf-lib');
      const pdfBytes = fs.readFileSync(filePath);
      const pdf = await PDFDocument.load(pdfBytes);
      const pageCount = pdf.getPageCount();

      return { success: true, pageCount };
    } catch (error: any) {
      console.error('[PDF] Error getting page count:', error);
      return { success: false, error: error.message };
    }
  });

  // PDF Tools - Split PDF (single file with selected pages)
  ipcMain.handle('split-pdf', async (event, filePath: string, pages: number[]) => {
    try {
      console.log('[PDF] Splitting PDF:', filePath, 'Pages:', pages);

      const { PDFDocument } = await import('pdf-lib');
      const pdfBytes = fs.readFileSync(filePath);
      const sourcePdf = await PDFDocument.load(pdfBytes);

      // Create new PDF with selected pages
      const newPdf = await PDFDocument.create();
      const copiedPages = await newPdf.copyPages(sourcePdf, pages);
      copiedPages.forEach((page) => newPdf.addPage(page));

      // Save split PDF
      const splitPdfBytes = await newPdf.save();

      // Ask user where to save
      const saveResult = await dialog.showSaveDialog(mainWindow!, {
        defaultPath: 'split.pdf',
        filters: [{ name: 'PDF Files', extensions: ['pdf'] }]
      });

      if (saveResult.canceled) {
        return { success: false, canceled: true };
      }

      // Write to file
      fs.writeFileSync(saveResult.filePath!, Buffer.from(splitPdfBytes));

      console.log('[PDF] Split PDF saved to:', saveResult.filePath);
      return { success: true, filePath: saveResult.filePath };
    } catch (error: any) {
      console.error('[PDF] Error splitting PDF:', error);
      return { success: false, error: error.message };
    }
  });

  // PDF Tools - Split PDF into individual pages
  ipcMain.handle('split-pdf-individual', async (event, filePath: string, pages: number[]) => {
    try {
      console.log('[PDF] Splitting PDF into individual files:', filePath, 'Pages:', pages);

      const { PDFDocument } = await import('pdf-lib');
      const pdfBytes = fs.readFileSync(filePath);
      const sourcePdf = await PDFDocument.load(pdfBytes);

      // Ask user where to save
      const saveResult = await dialog.showOpenDialog(mainWindow!, {
        properties: ['openDirectory', 'createDirectory'],
        title: 'Selecciona carpeta para guardar las páginas'
      });

      if (saveResult.canceled) {
        return { success: false, canceled: true };
      }

      const outputDir = saveResult.filePaths[0];
      const savedFiles: string[] = [];

      // Create individual PDF for each page
      for (const pageIndex of pages) {
        const newPdf = await PDFDocument.create();
        const [copiedPage] = await newPdf.copyPages(sourcePdf, [pageIndex]);
        newPdf.addPage(copiedPage);

        const pdfBytes = await newPdf.save();
        const fileName = `pagina_${pageIndex + 1}.pdf`;
        const filePath = path.join(outputDir, fileName);

        fs.writeFileSync(filePath, Buffer.from(pdfBytes));
        savedFiles.push(filePath);
      }

      console.log('[PDF] Individual PDFs saved:', savedFiles.length);
      return { success: true, count: savedFiles.length, directory: outputDir };
    } catch (error: any) {
      console.error('[PDF] Error splitting PDF individually:', error);
      return { success: false, error: error.message };
    }
  });

  // PDF Conversion - Images to PDF
  ipcMain.handle('images-to-pdf', async (event) => {
    try {
      console.log('[PDF] Converting images to PDF');

      // Select image files
      const selectResult = await dialog.showOpenDialog(mainWindow!, {
        properties: ['openFile', 'multiSelections'],
        filters: [
          { name: 'Images', extensions: ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff', 'webp'] },
          { name: 'All Files', extensions: ['*'] }
        ],
        title: 'Selecciona imágenes para convertir a PDF'
      });

      if (selectResult.canceled) {
        return { success: false, canceled: true };
      }

      const { PDFDocument } = await import('pdf-lib');
      const sharp = (await import('sharp')).default;

      const pdfDoc = await PDFDocument.create();

      // Process each image
      for (const imagePath of selectResult.filePaths) {
        console.log('[PDF] Processing image:', imagePath);

        // Convert image to JPEG buffer using sharp
        const imageBuffer = await sharp(imagePath)
          .jpeg({ quality: 90 })
          .toBuffer();

        // Embed image in PDF
        const image = await pdfDoc.embedJpg(imageBuffer);
        const page = pdfDoc.addPage([image.width, image.height]);
        page.drawImage(image, {
          x: 0,
          y: 0,
          width: image.width,
          height: image.height,
        });
      }

      // Ask where to save
      const saveResult = await dialog.showSaveDialog(mainWindow!, {
        defaultPath: 'converted.pdf',
        filters: [
          { name: 'PDF Files', extensions: ['pdf'] }
        ],
        title: 'Guardar PDF'
      });

      if (saveResult.canceled) {
        return { success: false, canceled: true };
      }

      const pdfBytes = await pdfDoc.save();
      fs.writeFileSync(saveResult.filePath!, Buffer.from(pdfBytes));

      console.log('[PDF] Images converted to PDF:', saveResult.filePath);
      return { success: true, filePath: saveResult.filePath };
    } catch (error: any) {
      console.error('[PDF] Error converting images to PDF:', error);
      return { success: false, error: error.message };
    }
  });

  // PDF Conversion - PDF to Images
  ipcMain.handle('pdf-to-images', async (event, filePath: string) => {
    try {
      console.log('[PDF] Converting PDF to images:', filePath);

      const { fromPath } = await import('pdf2pic');
      const { PDFDocument } = await import('pdf-lib');

      // Get page count first
      const pdfBytes = fs.readFileSync(filePath);
      const pdfDoc = await PDFDocument.load(pdfBytes);
      const pageCount = pdfDoc.getPageCount();

      console.log('[PDF] PDF has', pageCount, 'pages');

      // Ask where to save
      const saveResult = await dialog.showOpenDialog(mainWindow!, {
        properties: ['openDirectory', 'createDirectory'],
        title: 'Selecciona carpeta para guardar las imágenes'
      });

      if (saveResult.canceled) {
        return { success: false, canceled: true };
      }

      const outputDir = saveResult.filePaths[0];
      const baseName = path.basename(filePath, '.pdf');

      // Configure pdf2pic
      const options = {
        density: 150,           // DPI (higher = better quality, larger file)
        saveFilename: baseName,
        savePath: outputDir,
        format: 'png',
        width: 2480,           // A4 width at 150 DPI
        height: 3508           // A4 height at 150 DPI
      };

      const converter = fromPath(filePath, options);
      const savedFiles: string[] = [];

      // Convert each page
      for (let i = 1; i <= pageCount; i++) {
        console.log(`[PDF] Converting page ${i}/${pageCount}`);
        const pageResult = await converter(i, { responseType: 'image' });

        if (pageResult && pageResult.path) {
          savedFiles.push(pageResult.path);
          console.log('[PDF] Saved:', pageResult.path);
        }
      }

      console.log('[PDF] Conversion complete:', savedFiles.length, 'images saved');
      return { success: true, count: savedFiles.length, directory: outputDir };
    } catch (error: any) {
      console.error('[PDF] Error converting PDF to images:', error);
      return { success: false, error: error.message };
    }
  });
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  initDatabase();
  setupIPC();
  createWindow();

  // Registrar atajo global Command+Shift+T
  const ret = globalShortcut.register('CommandOrControl+Shift+T', () => {
    console.log('[SHORTCUT] CommandOrControl+Shift+T pressed');
    if (mainWindow && !mainWindow.isDestroyed()) {
      // Mostrar y enfocar la ventana si está minimizada u oculta
      if (mainWindow.isMinimized()) {
        mainWindow.restore();
      }
      if (!mainWindow.isVisible()) {
        mainWindow.show();
      }
      mainWindow.focus();

      // Enviar evento para toggle recording
      mainWindow.webContents.send('toggle-recording');
    }
  });

  if (!ret) {
    console.log('[SHORTCUT] Registration failed');
  } else {
    console.log('[SHORTCUT] CommandOrControl+Shift+T registered successfully');
  }

  // Verificar si el atajo está registrado
  console.log('[SHORTCUT] Is registered?', globalShortcut.isRegistered('CommandOrControl+Shift+T'));
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('will-quit', () => {
  // Unregister all shortcuts
  globalShortcut.unregisterAll();
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
