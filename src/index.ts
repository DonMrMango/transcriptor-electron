import { app, BrowserWindow, ipcMain, clipboard, dialog, globalShortcut } from 'electron';
import { spawn } from 'child_process';
import * as path from 'path';
import * as fs from 'fs';
import Database from 'better-sqlite3';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Global reference to the main window
let mainWindow: BrowserWindow | null = null;

const createWindow = (): void => {
  // Create a compact widget-style window
  mainWindow = new BrowserWindow({
    width: 320,
    height: 550,
    transparent: false,
    frame: false,
    alwaysOnTop: true,
    resizable: false,
    skipTaskbar: false,
    backgroundColor: '#1e1e2e',
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools in development mode
  if (process.env.NODE_ENV !== 'production') {
    mainWindow.webContents.openDevTools({ mode: 'detach' });
  }

  // Handle window closed
  mainWindow.on('closed', () => {
    mainWindow = null;
  });
};

// API Key storage
const API_KEY_FILE = path.join(app.getPath('userData'), 'groq_api_key.txt');

// Database setup
const DB_PATH = path.join(app.getPath('userData'), 'transcriptions.db');
let db: Database.Database | null = null;

function initDatabase() {
  try {
    console.log('[DB] Initializing database at:', DB_PATH);
    db = new Database(DB_PATH);

    // Create transcriptions table
    db.exec(`
      CREATE TABLE IF NOT EXISTS transcriptions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        text TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        duration REAL,
        language TEXT,
        model TEXT
      )
    `);

    console.log('[DB] Database initialized successfully');
  } catch (error) {
    console.error('[DB] Error initializing database:', error);
  }
}

// Setup IPC handlers once (globally)
function setupIPC() {
  // Control de ventana
  ipcMain.on('window-close', () => {
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.close();
    }
  });

  ipcMain.on('window-minimize', () => {
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.minimize();
    }
  });

  // Toggle recording (para atajo de teclado)
  ipcMain.on('toggle-recording-shortcut', () => {
    console.log('[SHORTCUT] Toggle recording triggered');
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.webContents.send('toggle-recording');
    }
  });

  // API Key management
  ipcMain.handle('get-api-key', async () => {
    try {
      console.log('[API_KEY] Checking for API key at:', API_KEY_FILE);
      if (fs.existsSync(API_KEY_FILE)) {
        const apiKey = fs.readFileSync(API_KEY_FILE, 'utf-8').trim();
        console.log('[API_KEY] Found API key:', apiKey.substring(0, 10) + '...');
        return apiKey;
      }
      console.log('[API_KEY] No API key file found');
      return null;
    } catch (error) {
      console.error('[API_KEY] Error reading API key:', error);
      return null;
    }
  });

  ipcMain.handle('save-api-key', async (event, apiKey: string) => {
    try {
      console.log('[API_KEY] Saving API key to:', API_KEY_FILE);
      fs.writeFileSync(API_KEY_FILE, apiKey.trim());
      console.log('[API_KEY] API key saved successfully');
      return { success: true };
    } catch (error: any) {
      console.error('[API_KEY] Error saving API key:', error);
      return { success: false, error: error.message };
    }
  });

  // File dialog para seleccionar archivo
  ipcMain.handle('open-file-dialog', async () => {
    try {
      const result = await dialog.showOpenDialog(mainWindow!, {
        properties: ['openFile'],
        filters: [
          { name: 'Audio/Video', extensions: ['mp3', 'wav', 'webm', 'mp4', 'm4a', 'ogg', 'flac', 'aac', 'wma', 'avi', 'mov', 'mkv'] },
          { name: 'All Files', extensions: ['*'] }
        ]
      });

      if (result.canceled) {
        return { success: false, canceled: true };
      }

      return { success: true, filePath: result.filePaths[0] };
    } catch (error: any) {
      console.error('[FILE_DIALOG] Error:', error);
      return { success: false, error: error.message };
    }
  });

  // Transcribir archivo desde path
  ipcMain.handle('transcribe-file', async (event, filePath: string, apiKey: string) => {
    try {
      console.log('[TRANSCRIBE_FILE] Starting transcription for file:', filePath);
      console.log('[TRANSCRIBE_FILE] API key:', apiKey.substring(0, 10) + '...');

      if (!fs.existsSync(filePath)) {
        return { success: false, error: 'File not found' };
      }

      // Ruta al CLI de Python
      const pythonCli = path.join(__dirname, '../../python-engine/cli.py');
      console.log('[TRANSCRIBE_FILE] Python CLI path:', pythonCli);

      // Llamar al CLI de Python directamente con el archivo
      return new Promise((resolve) => {
        const python = spawn('python3', [
          pythonCli,
          'transcribe',
          filePath,
          apiKey,
          'es',
          'whisper-large-v3-turbo'
        ], {
          stdio: ['ignore', 'pipe', 'pipe']
        });

        let outputData = '';
        let errorData = '';

        python.stdout.on('data', (data) => {
          const dataStr = data.toString();
          console.log('[TRANSCRIBE_FILE] Python stdout:', dataStr);
          outputData += dataStr;
        });

        python.stderr.on('data', (data) => {
          const dataStr = data.toString();
          console.log('[TRANSCRIBE_FILE] Python stderr:', dataStr);
          errorData += dataStr;
        });

        python.on('close', (code) => {
          console.log('[TRANSCRIBE_FILE] Python process closed with code:', code);

          if (code !== 0) {
            console.log('[TRANSCRIBE_FILE] Python failed with code:', code);
            resolve({ success: false, error: errorData || 'Error en transcripción' });
            return;
          }

          try {
            const result = JSON.parse(outputData);
            console.log('[TRANSCRIBE_FILE] Parsed result:', result);

            // Copiar al clipboard
            if (result.success && result.text) {
              clipboard.writeText(result.text);
              console.log('[TRANSCRIBE_FILE] Text copied to clipboard');
            }

            resolve(result);
          } catch (err) {
            console.error('[TRANSCRIBE_FILE] Error parsing JSON:', err);
            resolve({ success: false, error: 'Error parsing JSON: ' + err });
          }
        });

        python.on('error', (err) => {
          console.error('[TRANSCRIBE_FILE] Python process error:', err);
          resolve({ success: false, error: 'Failed to start Python: ' + err.message });
        });
      });
    } catch (error: any) {
      console.error('[TRANSCRIBE_FILE] Caught exception:', error);
      return { success: false, error: error.message };
    }
  });

  // Transcribir desde URL de YouTube
  ipcMain.handle('transcribe-youtube', async (event, youtubeUrl: string, apiKey: string) => {
    try {
      console.log('[TRANSCRIBE_YOUTUBE] Starting transcription for YouTube URL:', youtubeUrl);
      console.log('[TRANSCRIBE_YOUTUBE] API key:', apiKey.substring(0, 10) + '...');

      // Ruta al CLI de Python
      const pythonCli = path.join(__dirname, '../../python-engine/cli.py');
      console.log('[TRANSCRIBE_YOUTUBE] Python CLI path:', pythonCli);

      // Llamar al CLI de Python con el comando youtube
      return new Promise((resolve) => {
        const python = spawn('python3', [
          pythonCli,
          'youtube',
          youtubeUrl,
          apiKey,
          'es',
          'whisper-large-v3-turbo'
        ], {
          stdio: ['ignore', 'pipe', 'pipe']
        });

        let outputData = '';
        let errorData = '';

        python.stdout.on('data', (data) => {
          const dataStr = data.toString();
          console.log('[TRANSCRIBE_YOUTUBE] Python stdout:', dataStr);
          outputData += dataStr;
        });

        python.stderr.on('data', (data) => {
          const dataStr = data.toString();
          console.log('[TRANSCRIBE_YOUTUBE] Python stderr:', dataStr);
          errorData += dataStr;
        });

        python.on('close', (code) => {
          console.log('[TRANSCRIBE_YOUTUBE] Python process closed with code:', code);

          if (code !== 0) {
            console.log('[TRANSCRIBE_YOUTUBE] Python failed with code:', code);
            resolve({ success: false, error: errorData || 'Error descargando o transcribiendo YouTube' });
            return;
          }

          try {
            const result = JSON.parse(outputData);
            console.log('[TRANSCRIBE_YOUTUBE] Parsed result:', result);

            // Copiar al clipboard
            if (result.success && result.text) {
              clipboard.writeText(result.text);
              console.log('[TRANSCRIBE_YOUTUBE] Text copied to clipboard');
            }

            resolve(result);
          } catch (err) {
            console.error('[TRANSCRIBE_YOUTUBE] Error parsing JSON:', err);
            resolve({ success: false, error: 'Error parsing JSON: ' + err });
          }
        });

        python.on('error', (err) => {
          console.error('[TRANSCRIBE_YOUTUBE] Python process error:', err);
          resolve({ success: false, error: 'Failed to start Python: ' + err.message });
        });
      });
    } catch (error: any) {
      console.error('[TRANSCRIBE_YOUTUBE] Caught exception:', error);
      return { success: false, error: error.message };
    }
  });

  // Transcripción
  ipcMain.handle('transcribe-audio', async (event, audioBlob: Buffer, apiKey: string) => {
    try {
      console.log('[TRANSCRIBE] Starting transcription');
      console.log('[TRANSCRIBE] Audio blob size:', audioBlob.length, 'bytes');
      console.log('[TRANSCRIBE] API key:', apiKey.substring(0, 10) + '...');

      // Guardar el blob de audio temporalmente
      const tempDir = app.getPath('temp');
      const audioPath = path.join(tempDir, `recording-${Date.now()}.webm`);
      console.log('[TRANSCRIBE] Saving audio to:', audioPath);

      fs.writeFileSync(audioPath, audioBlob);
      console.log('[TRANSCRIBE] Audio saved successfully');

      // Ruta al CLI de Python
      const pythonCli = path.join(__dirname, '../../python-engine/cli.py');
      console.log('[TRANSCRIBE] Python CLI path:', pythonCli);
      console.log('[TRANSCRIBE] Python CLI exists?', fs.existsSync(pythonCli));

      // Llamar al CLI de Python
      return new Promise((resolve, reject) => {
        console.log('[TRANSCRIBE] Spawning Python process...');
        const python = spawn('python3', [
          pythonCli,
          'transcribe',
          audioPath,
          apiKey,
          'es',
          'whisper-large-v3-turbo'
        ], {
          stdio: ['ignore', 'pipe', 'pipe'] // stdin cerrado, stdout/stderr pipes
        });

        console.log('[TRANSCRIBE] Python process spawned');

        let outputData = '';
        let errorData = '';

        python.stdout.on('data', (data) => {
          const dataStr = data.toString();
          console.log('[TRANSCRIBE] Python stdout:', dataStr);
          outputData += dataStr;
        });

        python.stderr.on('data', (data) => {
          const dataStr = data.toString();
          console.log('[TRANSCRIBE] Python stderr:', dataStr);
          errorData += dataStr;
        });

        python.on('close', (code) => {
          console.log('[TRANSCRIBE] Python process closed with code:', code);
          // Limpiar archivo temporal
          try {
            fs.unlinkSync(audioPath);
          } catch (err) {
            console.error('Error deleting temp file:', err);
          }

          if (code !== 0) {
            console.log('[TRANSCRIBE] Python failed with code:', code);
            console.log('[TRANSCRIBE] Error output:', errorData);
            resolve({ success: false, error: errorData || 'Error en transcripción' });
            return;
          }

          try {
            console.log('[TRANSCRIBE] Parsing JSON output:', outputData);
            const result = JSON.parse(outputData);
            console.log('[TRANSCRIBE] Parsed result:', result);

            // Copiar al clipboard automáticamente
            if (result.success && result.text) {
              console.log('[TRANSCRIBE] Copying to clipboard:', result.text.substring(0, 50) + '...');
              clipboard.writeText(result.text);
              console.log('[TRANSCRIBE] Text copied to clipboard');
            }

            resolve(result);
          } catch (err) {
            console.error('[TRANSCRIBE] Error parsing JSON:', err);
            console.log('[TRANSCRIBE] Raw output was:', outputData);
            resolve({ success: false, error: 'Error parsing JSON: ' + err });
          }
        });

        python.on('error', (err) => {
          console.error('[TRANSCRIBE] Python process error:', err);
          resolve({ success: false, error: 'Failed to start Python: ' + err.message });
        });
      });
    } catch (error: any) {
      console.error('[TRANSCRIBE] Caught exception:', error);
      return { success: false, error: error.message };
    }
  });

  // Historial
  ipcMain.handle('save-transcription', async (event, data: any) => {
    try {
      if (!db) {
        console.error('[DB] Database not initialized');
        return { success: false, error: 'Database not initialized' };
      }

      console.log('[DB] Saving transcription:', data);

      const stmt = db.prepare(`
        INSERT INTO transcriptions (text, timestamp, duration, language, model)
        VALUES (?, ?, ?, ?, ?)
      `);

      const info = stmt.run(
        data.text,
        data.timestamp || Date.now(),
        data.duration || null,
        data.language || 'es',
        data.model || 'whisper-large-v3-turbo'
      );

      console.log('[DB] Transcription saved with id:', info.lastInsertRowid);
      return { success: true, id: info.lastInsertRowid };
    } catch (error: any) {
      console.error('[DB] Error saving transcription:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('get-history', async () => {
    try {
      if (!db) {
        console.error('[DB] Database not initialized');
        return [];
      }

      console.log('[DB] Retrieving transcription history');

      const stmt = db.prepare(`
        SELECT * FROM transcriptions
        ORDER BY timestamp DESC
        LIMIT 100
      `);

      const rows = stmt.all();
      console.log('[DB] Retrieved', rows.length, 'transcriptions');

      return rows;
    } catch (error: any) {
      console.error('[DB] Error retrieving history:', error);
      return [];
    }
  });
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  initDatabase();
  setupIPC();
  createWindow();

  // Registrar atajo global Command+Shift+T
  const ret = globalShortcut.register('CommandOrControl+Shift+T', () => {
    console.log('[SHORTCUT] CommandOrControl+Shift+T pressed');
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.webContents.send('toggle-recording');
    }
  });

  if (!ret) {
    console.log('[SHORTCUT] Registration failed');
  } else {
    console.log('[SHORTCUT] CommandOrControl+Shift+T registered successfully');
  }

  // Verificar si el atajo está registrado
  console.log('[SHORTCUT] Is registered?', globalShortcut.isRegistered('CommandOrControl+Shift+T'));
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('will-quit', () => {
  // Unregister all shortcuts
  globalShortcut.unregisterAll();
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
